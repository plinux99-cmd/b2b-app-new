================================================================================
TROUBLESHOOTING COMMANDS - AeroWise Infrastructure
Debugging assetservice 500 Error & Network Policy Issues
================================================================================

PURPOSE: This document contains all commands executed during troubleshooting,
organized by category with explanations. Use these commands to validate the
infrastructure state and diagnose similar issues in the future.

================================================================================
1. NETWORK POLICY DIAGNOSIS
================================================================================

1.1 Check Current Network Policies
PURPOSE: View all network policies in the mobileapp namespace to understand
         traffic restrictions.
COMMAND:
  kubectl get networkpolicies -n mobileapp

EXPECTED OUTPUT:
  NAME                   POD-SELECTOR   AGE
  allow-app-to-db        <none>         ...
  allow-dns              <none>         ...
  allow-https-egress     <none>         ...
  allow-same-namespace   <none>         ...
  allow-vpc-to-app       <none>         ...
  allow-app-to-app       <none>         ... (newly created)

---

1.2 Inspect Specific Network Policy Details
PURPOSE: Get full YAML definition of a network policy to verify ingress/egress
         rules.
COMMAND:
  kubectl get networkpolicy allow-vpc-to-app -n mobileapp -o yaml

EXPECTED OUTPUT:
  Shows ingress rules allowing both 10.0.0.0/16 (pod CIDR) and 10.100.0.0/16
  (Kubernetes service CIDR) on port 80/TCP.

---

1.3 Check All Network Policies with Description
PURPOSE: Get human-readable description of all policies including rules.
COMMAND:
  kubectl describe networkpolicy allow-vpc-to-app -n mobileapp

PURPOSE (alternative - check same-namespace policy):
COMMAND:
  kubectl get networkpolicy allow-same-namespace -n mobileapp -o yaml

PURPOSE (alternative - check egress policy):
COMMAND:
  kubectl describe networkpolicy allow-app-to-db -n mobileapp | head -20

---

1.4 Check Calico Global Network Policies
PURPOSE: Verify if Calico is applying global policies that might override
         namespace policies.
COMMAND:
  kubectl get globalnetworkpolicies

EXPECTED OUTPUT:
  No resources found
  (If policies exist, they may be blocking traffic at a higher level)

================================================================================
2. POD-TO-POD CONNECTIVITY TESTS
================================================================================

2.1 Test Pod-to-Pod Communication via Service
PURPOSE: Verify if app1 pod can reach app2 service (ClusterIP) on port 80.
         This tests service DNS resolution and network policy egress.
COMMAND:
  kubectl exec -n mobileapp $(kubectl get pods -n mobileapp -l app=app1 -o jsonpath='{.items[0].metadata.name}') -- curl -s -m 5 http://app2-svc:80/assetservice 2>&1

EXPECTED OUTPUT (BEFORE FIX):
  command terminated with exit code 28
  (Timeout = network policy blocking egress)

EXPECTED OUTPUT (AFTER FIX):
  {"service":"app2","version":"1.0.0","status":"ok","note":"Pramod-testing2"}

---

2.2 Test Pod-to-Pod Communication via Direct IP
PURPOSE: Bypass service DNS and test direct pod-to-pod connectivity.
         Use actual pod IP from `kubectl get pods -n mobileapp -o wide`.
COMMAND:
  kubectl exec -n mobileapp $(kubectl get pods -n mobileapp -l app=app1 -o jsonpath='{.items[0].metadata.name}') -- curl -s -m 5 http://10.0.12.94:80/assetservice 2>&1 | head -20

EXPECTED OUTPUT (BEFORE FIX):
  command terminated with exit code 28
  (Exit code 28 = timeout)

EXPECTED OUTPUT (AFTER FIX):
  {"service":"app2","version":"1.0.0","status":"ok","note":"Pramod-testing2"}

---

2.3 Resolve Service DNS Name
PURPOSE: Confirm that Kubernetes service DNS resolves to the ClusterIP.
         This helps identify if the service is in the correct CIDR range
         (should be 10.100.0.0/16, NOT 10.0.0.0/16).
COMMAND:
  kubectl exec -n mobileapp $(kubectl get pods -n mobileapp -l app=app1 -o jsonpath='{.items[0].metadata.name}') -- nslookup app2-svc

EXPECTED OUTPUT:
  Name: app2-svc.mobileapp.svc.cluster.local
  Address: 10.100.121.147
  (Notice the 10.100.0.0/16 CIDR, not 10.0.0.0/16)

KEY INSIGHT: If service IPs are in a different CIDR than pod IPs, network
             policies must allow BOTH ranges for service-to-service communication.

================================================================================
3. NETWORK POLICY FIXES
================================================================================

3.1 Add Service CIDR to Existing Ingress Policy (ATTEMPTED FIX)
PURPOSE: Allow traffic from Kubernetes service CIDR (10.100.0.0/16) to pods
         on port 80. This was the first attempted fix but only solved ingress,
         not egress.
COMMAND:
  kubectl patch networkpolicy allow-vpc-to-app -n mobileapp --type=json -p='[{"op": "add", "path": "/spec/ingress/0/from/-", "value": {"ipBlock": {"cidr": "10.100.0.0/16"}}}]'

EXPECTED OUTPUT:
  networkpolicy.networking.k8s.io/allow-vpc-to-app patched

NOTE: This fix allows INCOMING traffic from service IPs to reach pods, but
      pods still couldn't send outbound traffic on port 80 (no egress rule).

---

3.2 Create New Egress Policy for Pod-to-Pod Communication (ACTUAL FIX)
PURPOSE: Allow pods to initiate outbound connections to other pods on port 80.
         This was the missing piece - egress rules were incomplete.
COMMAND:
  cat <<'EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-app-to-app
  namespace: mobileapp
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - podSelector: {}
      namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: mobileapp
    ports:
    - protocol: TCP
      port: 80
EOF

EXPECTED OUTPUT:
  networkpolicy.networking.k8s.io/allow-app-to-app created

VERIFICATION (run immediately after):
  kubectl exec -n mobileapp $(kubectl get pods -n mobileapp -l app=app1 -o jsonpath='{.items[0].metadata.name}') -- curl -s http://app2-svc:80/assetservice

EXPECTED OUTPUT:
  {"service":"app2","version":"1.0.0","status":"ok","note":"Pramod-testing2"}

================================================================================
4. POD & DEPLOYMENT INSPECTION
================================================================================

4.1 List All Pods with IP Addresses
PURPOSE: See all running pods, their IPs, and node assignments.
         Use to verify pod IPs are in correct subnet (10.0.x.x).
COMMAND:
  kubectl get pods -n mobileapp -o wide

EXPECTED OUTPUT:
  NAME                    READY   STATUS    AGE   IP            NODE
  app1-779d866888-2zt69   1/1     Running   53m   10.0.12.35    ip-10-0-12-118...
  app1-779d866888-c4b2l   1/1     Running   53m   10.0.11.174   ip-10-0-11-77...
  app2-bb85895bf-w5bl6    1/1     Running   19m   10.0.11.190   ip-10-0-11-77...
  app2-bb85895bf-wjpbn    1/1     Running   19m   10.0.12.94    ip-10-0-12-118...

---

4.2 List Pods with Labels
PURPOSE: Verify pods have correct labels for network policy selectors.
COMMAND:
  kubectl get pods -n mobileapp -o wide --show-labels

EXPECTED OUTPUT:
  Shows LABELS column with app=app1, app=app2, pod-template-hash values

---

4.3 Check Deployment Rollout Status
PURPOSE: Ensure deployment successfully deployed after ConfigMap changes.
COMMAND:
  kubectl rollout status deployment/app2 -n mobileapp --timeout=60s

EXPECTED OUTPUT:
  deployment "app2" successfully rolled out

---

4.4 Force Pod Restart (Redeploy)
PURPOSE: Restart pods to pick up new ConfigMap values or network policy changes.
COMMAND:
  kubectl rollout restart deployment/app2 -n mobileapp

EXPECTED OUTPUT:
  deployment.apps/app2 restarted

================================================================================
5. KUBERNETES CONFIGMAP & SERVICE INSPECTION
================================================================================

5.1 Check ConfigMap Content
PURPOSE: Verify nginx configuration for the app (includes response JSON).
COMMAND:
  kubectl get configmap app2-config -n mobileapp -o yaml

EXPECTED OUTPUT:
  Shows nginx.conf with location blocks and JSON responses
  Look for: {"service":"app2","version":"1.0.0","status":"ok","note":"Pramod-testing2"}
  (Make sure JSON is properly formatted with quotes)

---

5.2 List All Services and Their ClusterIPs
PURPOSE: See all Kubernetes services and their internal IP addresses.
COMMAND:
  kubectl get services -n mobileapp

EXPECTED OUTPUT:
  NAME        TYPE        CLUSTER-IP        EXTERNAL-IP   PORT(S)
  app1-svc    ClusterIP   10.100.245.208    <none>        80/TCP
  app2-svc    ClusterIP   10.100.121.147    <none>        80/TCP

================================================================================
6. AWS ALB HEALTH & ROUTING
================================================================================

6.1 List All Target Groups
PURPOSE: Find app2 target group (name changes due to Terraform recreation).
COMMAND:
  aws elbv2 describe-target-groups --region us-east-1 | jq '.TargetGroups[] | select(.TargetGroupName | contains("app2")) | {Name: .TargetGroupName, Arn: .TargetGroupArn}'

EXPECTED OUTPUT:
  Multiple target groups with names like:
  k8s-mobileap-app2svc-45e57de53c
  k8s-mobileap-app2svc-6c4ba63a7e
  k8s-mobileap-app2svc-dd389e0f23

---

6.2 Get ALB Listener Details
PURPOSE: Find the correct listener ARN for the ALB.
COMMAND:
  aws elbv2 describe-listeners --load-balancer-arn "arn:aws:elasticloadbalancing:us-east-1:339712886638:loadbalancer/app/k8s-mobileap-mobileap-3ad48e132b/dd6159cb3cd5dffe" --region us-east-1 | jq '.Listeners[] | {Port: .Port, Arn: .ListenerArn}'

EXPECTED OUTPUT:
  Shows listener ARN like:
  arn:aws:elasticloadbalancing:us-east-1:339712886638:listener/app/k8s-mobileap-mobileap-3ad48e132b/dd6159cb3cd5dffe/74b9b8bee09dfac1

---

6.3 Find ALB Rules for Specific Path
PURPOSE: Verify ALB routing rules for /assetservice path.
COMMAND:
  aws elbv2 describe-rules --listener-arn "arn:aws:elasticloadbalancing:us-east-1:339712886638:listener/app/k8s-mobileap-mobileap-3ad48e132b/dd6159cb3cd5dffe/74b9b8bee09dfac1" --region us-east-1 | jq '.Rules[] | select(.Conditions[].Values[] | contains("assetservice")) | {Priority: .Priority, Path: .Conditions[].Values, TargetGroup: .Actions[].TargetGroupArn}'

EXPECTED OUTPUT:
  Shows priority 2 rule for /assetservice and /assetservice/*
  Routes to: k8s-mobileap-app2svc-45e57de53c target group

---

6.4 Check Target Health for app2
PURPOSE: Verify that app2 pods are registered as healthy targets in the ALB.
COMMAND:
  aws elbv2 describe-target-health --target-group-arn "arn:aws:elasticloadbalancing:us-east-1:339712886638:targetgroup/k8s-mobileap-app2svc-45e57de53c/eb45ba252c43e89f" --region us-east-1 | jq '.TargetHealthDescriptions[] | {IP: .Target.Id, State: .TargetHealth.State, Reason: .TargetHealth.Reason}'

EXPECTED OUTPUT:
  {
    "IP": "10.0.11.190",
    "State": "healthy",
    "Reason": null
  }
  {
    "IP": "10.0.12.94",
    "State": "healthy",
    "Reason": null
  }

---

6.5 Get ALB DNS Name
PURPOSE: Get the internal ALB DNS name for testing.
COMMAND:
  aws elbv2 describe-load-balancers --load-balancer-arns "arn:aws:elasticloadbalancing:us-east-1:339712886638:loadbalancer/app/k8s-mobileap-mobileap-3ad48e132b/dd6159cb3cd5dffe" --region us-east-1 | jq '.LoadBalancers[0].DNSName'

EXPECTED OUTPUT:
  "internal-k8s-mobileap-mobileap-3ad48e132b-387756266.us-east-1.elb.amazonaws.com"

================================================================================
7. LAMBDA AUTHORIZER TESTING
================================================================================

7.1 Test Lambda Authorizer Directly
PURPOSE: Verify the Lambda authorizer returns correct response format for
         API Gateway v2.
COMMAND:
  cat > /tmp/auth_payload.json <<'EOF'
{
  "version": "2.0",
  "routeKey": "POST /assetservice",
  "rawPath": "/assetservice",
  "headers": {
    "authorization": "test-token"
  },
  "requestContext": {
    "http": {
      "method": "POST"
    }
  }
}
EOF
aws lambda invoke --function-name aerowise-t1-authorizer --region us-east-1 --payload file:///tmp/auth_payload.json /tmp/response.json 2>&1 && cat /tmp/response.json | jq .

EXPECTED OUTPUT:
  {"isAuthorized": true, "context": {"principalId": "user", "username": "authenticated-user"}}

---

7.2 Check Lambda Resource-Based Policy
PURPOSE: Verify that API Gateway has permission to invoke the authorizer.
COMMAND:
  aws lambda get-policy --function-name aerowise-t1-authorizer --region us-east-1 2>&1 | jq '.Policy | fromjson | .Statement[]'

EXPECTED OUTPUT:
  Shows statement with:
  - Effect: Allow
  - Principal: apigateway.amazonaws.com
  - Action: lambda:InvokeFunction
  - Resource: arn:aws:lambda:us-east-1:...:function:aerowise-t1-authorizer
  - Condition: SourceArn includes the API Gateway API

================================================================================
8. API GATEWAY INSPECTION
================================================================================

8.1 Get API Gateway Details
PURPOSE: Verify API Gateway is HTTP (v2) and has correct name/ID.
COMMAND:
  aws apigatewayv2 get-api --api-id hdfskqffs3 --region us-east-1 | jq '{ApiId: .ApiId, ProtocolType: .ProtocolType, Name: .Name}'

EXPECTED OUTPUT:
  {
    "ApiId": "hdfskqffs3",
    "ProtocolType": "HTTP",
    "Name": "aerowise-t1-apigw-prod"
  }

---

8.2 Get Integration Details
PURPOSE: Check HTTP proxy integration settings including timeout.
COMMAND:
  aws apigatewayv2 get-integrations --api-id hdfskqffs3 --region us-east-1 | jq '.Items[] | select(.IntegrationType == "HTTP_PROXY") | {IntegrationId: .IntegrationId, IntegrationType: .IntegrationType, IntegrationUri: .IntegrationUri, TimeoutInMillis: .TimeoutInMillis}'

EXPECTED OUTPUT:
  {
    "IntegrationId": "4q8oqzu",
    "IntegrationType": "HTTP_PROXY",
    "IntegrationUri": "arn:aws:elasticloadbalancing:us-east-1:339712886638:listener/app/...",
    "TimeoutInMillis": 29000
  }

---

8.3 List All API Gateway Routes
PURPOSE: See all routes and which ones have authorizers attached.
COMMAND:
  aws apigatewayv2 get-routes --api-id hdfskqffs3 --region us-east-1 | jq '.Items[] | {RouteKey: .RouteKey, AuthorizationType: .AuthorizationType, AuthorizerId: .AuthorizerId}' | head -50

EXPECTED OUTPUT:
  Shows routes like:
  - POST /assetservice with AuthorizationType: CUSTOM, AuthorizerId: <id>
  - GET /app-version/check with AuthorizationType: NONE

================================================================================
9. API ENDPOINT TESTING
================================================================================

9.1 Test Public Endpoint (No Auth Required)
PURPOSE: Verify /app-version/check works (should return 200).
         This endpoint doesn't require authorization.
COMMAND:
  curl -s -i https://hdfskqffs3.execute-api.us-east-1.amazonaws.com/app-version/check 2>&1

EXPECTED OUTPUT:
  HTTP/2 200
  content-type: application/json
  
  {"version":"1.0.0","status":"ok","message":"App is running"}

---

9.2 Test Protected Endpoint Without Auth (Should Fail)
PURPOSE: Verify /assetservice requires authorization.
         Without token, should return 401.
COMMAND:
  curl -s -i https://hdfskqffs3.execute-api.us-east-1.amazonaws.com/assetservice 2>&1

EXPECTED OUTPUT:
  HTTP/2 401
  {"message":"Unauthorized"}

---

9.3 Test Protected Endpoint With Auth Token
PURPOSE: Test /assetservice with authorization header.
         Should pass through Lambda authorizer and return from app2.
COMMAND:
  curl -s -i -H "Authorization: test-token" https://hdfskqffs3.execute-api.us-east-1.amazonaws.com/assetservice 2>&1

EXPECTED OUTPUT (AFTER ALL FIXES):
  HTTP/2 200
  content-type: application/json
  
  {"service":"app2","version":"1.0.0","status":"ok","note":"Pramod-testing2"}

CURRENT OUTPUT (ISSUE):
  HTTP/2 500
  {"message":"Internal Server Error"}

================================================================================
10. VPC LINK INSPECTION
================================================================================

10.1 List VPC Links
PURPOSE: Check VPC Link status and target group associations.
COMMAND:
  aws apigatewayv2 get-vpc-links --region us-east-1 | jq '.Items[] | {VpcLinkId: .Id, Name: .Name, Status: .Status, SubnetIds: .SubnetIds}'

EXPECTED OUTPUT:
  Shows VPC Link with ID like "m6rsbc" and Status: "available"

---

10.2 Get VPC Link Details
PURPOSE: Get detailed VPC Link configuration and security group.
COMMAND:
  aws apigatewayv2 get-vpc-link --vpc-link-id m6rsbc --region us-east-1 | jq '{VpcLinkId: .Id, Status: .Status, SecurityGroupIds: .SecurityGroupIds, SubnetIds: .SubnetIds}'

EXPECTED OUTPUT:
  Shows VPC Link with security group allowing outbound to ALB SG

================================================================================
11. TROUBLESHOOTING CHECKLIST
================================================================================

When assetservice returns 500, follow this checklist:

STEP 1: Network Policies
☐ Run: kubectl get networkpolicies -n mobileapp
☐ Verify: allow-app-to-app policy exists with egress rules
☐ Verify: allow-vpc-to-app policy allows 10.100.0.0/16 ingress

STEP 2: Pod-to-Pod Connectivity
☐ Run: kubectl exec <app1-pod> -- curl -m 5 http://app2-svc:80/assetservice
☐ Expected: Returns JSON response (not timeout)

STEP 3: Lambda Authorizer
☐ Run: aws lambda invoke ... aerowise-t1-authorizer
☐ Expected: Returns isAuthorized: true

STEP 4: ALB Health
☐ Run: aws elbv2 describe-target-health ... (app2 target group)
☐ Expected: All targets show "healthy"

STEP 5: API Gateway Routes
☐ Run: aws apigatewayv2 get-routes --api-id hdfskqffs3
☐ Expected: /assetservice routes have AuthorizationType: CUSTOM

STEP 6: VPC Link Status
☐ Run: aws apigatewayv2 get-vpc-links
☐ Expected: VPC Link status is "available"

STEP 7: Test Full Chain
☐ Run: curl -H "Authorization: test-token" https://hdfskqffs3.execute-api.us-east-1.amazonaws.com/assetservice
☐ Expected: HTTP 200 with JSON response

================================================================================
12. QUICK REFERENCE - CIDR RANGES
================================================================================

VPC CIDR:                    10.0.0.0/16     (Pod IPs)
Kubernetes Service CIDR:     10.100.0.0/16   (ClusterIP IPs)
RDS CIDR:                    10.0.10.0/16    (Database endpoint)

Network policies MUST allow both 10.0.0.0/16 AND 10.100.0.0/16 for
service-to-service communication to work.

================================================================================
END OF TROUBLESHOOTING GUIDE
================================================================================
